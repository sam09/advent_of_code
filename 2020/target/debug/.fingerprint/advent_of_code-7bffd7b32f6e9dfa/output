{"message":"cannot apply unary operator `!` to type `std::result::Result<_, ()>`","code":{"code":"E0600","explanation":"An unary operator was used on a type which doesn't implement it.\n\nExample of erroneous code:\n\n```compile_fail,E0600\nenum Question {\n    Yes,\n    No,\n}\n\n!Question::Yes; // error: cannot apply unary operator `!` to type `Question`\n```\n\nIn this case, `Question` would need to implement the `std::ops::Not` trait in\norder to be able to use `!` on it. Let's implement it:\n\n```\nuse std::ops::Not;\n\nenum Question {\n    Yes,\n    No,\n}\n\n// We implement the `Not` trait on the enum.\nimpl Not for Question {\n    type Output = bool;\n\n    fn not(self) -> bool {\n        match self {\n            Question::Yes => false, // If the `Answer` is `Yes`, then it\n                                    // returns false.\n            Question::No => true, // And here we do the opposite.\n        }\n    }\n}\n\nassert_eq!(!Question::Yes, false);\nassert_eq!(!Question::No, true);\n```\n"},"level":"error","spans":[{"file_name":"src/day19.rs","byte_start":2306,"byte_end":2367,"line_start":84,"line_end":84,"column_start":5,"column_end":66,"is_primary":true,"text":[{"text":"    assert!(Err(()), rule_map[&11].match_rule(\"aab\", &rule_map));","highlight_start":5,"highlight_end":66}],"label":"cannot apply unary operator `!`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/day19.rs","byte_start":2306,"byte_end":2367,"line_start":84,"line_end":84,"column_start":5,"column_end":66,"is_primary":false,"text":[{"text":"    assert!(Err(()), rule_map[&11].match_rule(\"aab\", &rule_map));","highlight_start":5,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert!","def_site_span":{"file_name":"<::core::macros::builtin::assert macros>","byte_start":0,"byte_end":105,"line_start":1,"line_end":2,"column_start":1,"column_end":47,"is_primary":false,"text":[{"text":"($ cond : expr) => { { } } ; ($ cond : expr,) => { { } } ;","highlight_start":1,"highlight_end":59},{"text":"($ cond : expr, $ ($ arg : tt) +) => { { } } ;","highlight_start":1,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0600]\u001b[0m\u001b[0m\u001b[1m: cannot apply unary operator `!` to type `std::result::Result<_, ()>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/day19.rs:84:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    assert!(Err(()), rule_map[&11].match_rule(\"aab\", &rule_map));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot apply unary operator `!`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0600`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0600`.\u001b[0m\n"}
